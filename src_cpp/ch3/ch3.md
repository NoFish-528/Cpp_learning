# 处理数据
内置的c++类型分为两组：基本类型和复合类型，基本类型包括整数和浮点数。复合类型是基于基本类型创建出来的，包括数组、字符串、指针和结构

## 简单变量
c++的基本整型从小到大包括char，short，int，long和c++11新增的long long。每种又包括了符号版本和无符号版本，总共有10类可以选择，这部分与c语言类似。不做过多赘述。需要进行赋值运算符或者()初始化，在c++11普及后，我们可以使用{}（大括号初始化器）用于任何类型（可以使用等号，也可以不使用等号）
```cpp
int emus{7};
int emus={7};
```

## 选择整形类型
int 为自然长度，自然长度是计算机处理起来效率最高的长度。但不是固定的，根据实际情况选择。

## const限定符
- 创建常量的通用格式如下：
```cpp
const type name = value;
```
- 与#define的区别

    - const 明确指出了类型，编译器可以进行安全检查；#define宏定义没有数据类型，只是简单的字符串替换，不能进行安全检查。
    - 可以将作用域限制在特定的函数或者文件中
    - const 可以用于更加复杂的数据结构 
    - 防止修改，起到保护作用，增加程序的健壮性，不能修改
    ```cpp
    void f(const int i){
        i++; //error
    }
    ```
    - 节省空间，避免不必要的内存分配

        - const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数。
        - const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。 

## 类型转换
### 初始化和赋值进行的转换
这种情况只适合小转大，具体例子如下：
```cpp
//so_long :long
// thirty :short
so_long = thirty;
```
程序将thirty扩展为long值并且赋值给so_long。将一个值赋值给取值范围更大的类型不会出现太大问题，只是会占用更多的字节而已。但是当我们大专小的时候会出现很多问题。如double--> float,float --> int, long-->short。

### 表达式中的转换

### 以{}方式初始化进行转化

### 传递参数时的转换

### 强制类型转换
格式：
```cpp
(typename) value;
typename (value);  //将强制类型转换类似函数调用
```

### c++11 的auto声明
使用关键字auto，不指定变量类型，编译器将把变量的类型设置成与初始值相同。
```cpp
auto x = 100; //x is int
auto n = 1.5; //n is double
auto m = 1.3e12L; //m is long double
```